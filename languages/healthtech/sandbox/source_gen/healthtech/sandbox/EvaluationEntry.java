package healthtech.sandbox;

/*Generated by MPS */

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.ArrayList;

public class EvaluationEntry {
  private List<Range> ranges;
  private OutputResult result;

  public List<Range> getRanges() {
    return this.ranges;
  }
  public void setRanges(List<Range> ranges) {
    this.ranges = ranges;
  }
  public OutputResult getResult() {
    return this.result;
  }
  public void setResult(OutputResult result) {
    this.result = result;
  }

  public List<OutputResult> evaluate(Map<MType, List<Measurement>> measurements) {
    Map<Range, Boolean> rangeCheckResults = new HashMap<Range, Boolean>();
    for (final Range range : ranges) {
      Optional<MType> type = measurements.keySet().stream().filter(new Predicate<MType>() {
        public boolean test(MType type) {
          return isTypeSuported(range, type);
        }
      }).findFirst();
      if (type.isPresent()) {
        List<Measurement> rangeSpecificMeasurements = measurements.get(type.get());
        int successChecks = 0;
        for (Measurement measurement : rangeSpecificMeasurements) {
          if (range.checkRange(measurement)) {
            successChecks++;
          }
        }
        // here we check that number of measurements that satisfy current range is more than 80% 
        if (successChecks >= rangeSpecificMeasurements.size() * 0.8) {
          rangeCheckResults.put(range, true);
        } else {
          rangeCheckResults.put(range, false);
        }
      }
    }
    if (validateRangeCheckResults(rangeCheckResults)) {
      return List.of(result);
    }
    return new ArrayList<OutputResult>();
  }

  private boolean isTypeSuported(Range range, MType type) {
    boolean isSupported = false;
    if (type == MType.PRESSURE) {
      isSupported = range.getType() == MType.DIASTOLIC || range.getType() == MType.SYSTOLIC;
    } else {
      isSupported = range.getType() == type;
    }
    return isSupported;
  }


  private boolean validateRangeCheckResults(Map<Range, Boolean> checkResults) {
    // in future might be considered f.e. 'OR' semantics here that is based on some specific range concept, separate concept and etc. 
    return checkResults.keySet().size() == ranges.size() && checkResults.values().stream().allMatch(new Predicate<Boolean>() {
      public boolean test(Boolean res) {
        return res == true;
      }
    });
  }

}
